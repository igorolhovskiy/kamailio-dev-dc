#!KAMAILIO

#!define FROM_TO_PER_SECOND_RATIO 3

debug=2
log_stderror=no

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="[$mt $hdr(CSeq) $ci] "

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=4

/* uncomment the next line to disable TCP (default on) */

/* number of SIP routing processes for all TCP/TLS sockets */
# tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
# auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to
 * bind on a specific interface/port/proto (default bind on all available) */
disable_tcp=yes
listen=udp:eth0:5060
/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */

/* upper limit for TCP connections (it includes the TLS connections) */
# tcp_max_connections=2048


####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "tm.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "sl.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "counters.so"
loadmodule "rr.so"
loadmodule "htable.so"

modparam("htable", "htable", "fu_tu=>size=5;autoexpire=5;")

####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

    xlog("[$TF] $rm received\n");

    if (is_method("REGISTER")) {

        route(LOOP_PROTECTION);
        sl_send_reply("200", "OK, Registered");
    }
}

route[LOOP_PROTECTION] {

    $var(from_to_hash) = $fU + '_' + $tU + '_' + $timef(%H_%M_%S);

    if ($sht(fu_tu=>$var(from_to_hash)) != $null) {
        $sht(fu_tu=>$var(from_to_hash)) = $sht(fu_tu=>$var(from_to_hash)) + 1;
        xlog("[LOOP_PROTECTION]: Possible loop detected on call $fu -> $tu ($sht(fu_tu=>$var(from_to_hash)) total calls during last second)\n");
    } else {
        $sht(fu_tu=>$var(from_to_hash)) = 1;
        xlog("[LOOP_PROTECTION]: Loop protection enabled on call $fu -> $tu with $var(from_to_hash) hash)\n");
    }

    if ($sht(fu_tu=>$var(from_to_hash)) > FROM_TO_PER_SECOND_RATIO) {
        xlog("[LOOP_PROTECTION]: Loop detected on call $fu -> $tu (IP:$si:$sp)\n");
        send_reply("482","Loop detected");
        exit;
    }

}

reply_route {   
    xlog("[REPLY_ROUTE][$TF] $rs reply for $rm received\n");
}

failure_route {
    xlog("[FAILURE_ROUTE][$TF] failure $rm received\n");
}