#!KAMAILIO

debug=2
log_stderror=no

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="[$mt $hdr(CSeq) $ci] "

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=4

/* uncomment the next line to disable TCP (default on) */
disable_tcp=no

/* number of SIP routing processes for all TCP/TLS sockets */
# tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
# auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to
 * bind on a specific interface/port/proto (default bind on all available) */
listen=tcp:eth0:5060

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

/* upper limit for TCP connections (it includes the TLS connections) */
# tcp_max_connections=2048


####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "tm.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "sl.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "counters.so"
loadmodule "rr.so"


####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

    xlog("[$TF] $rm received\n");

    if (is_method("REGISTER")) {
        sl_send_reply("200", "OK, Registered");

        route(REGISTER_PROCESS);
    }
}

route[REGISTER_PROCESS] {

    xlog("[$TF] INVITE is sent back..\n");

    // Also possible to send via simple send_data(). 
    // "BYE sip:"..faultEndpoint.." SIP/2.0\n".."Via: SIP/2.0/UDP "..config.myAddr..";branch=z9hG4bK"..callId.."\n".."From: "..from.."\n".."To: "..to.."\n".."CSeq: "..cSeq.." BYE\n".."Call-ID: " ..callId.. "\nContent-length: 0\n"

    $var(invite_message) = "INVITE " + $fu + "SIP/2.0\n" +
                            "Via: SIP/2.0/TCP " + $tu + ";branch=z9hG4bK_" + $ci + "\n" +
                            "From: sip:dummy@" + $fd + "\n" +
                            "To: " + $fu + "\n" + 
                            "Call-ID: " + $ci + "_senddata\n" + 
                            "CSeq: 1 INVITE\n" + 
                            "Contact: sip:dummy@" + $fd + "\n" +
                            "Allow: INVITE, CANCEL, BYE, ACK, REGISTER, OPTIONS, REFER, SUBSCRIBE, NOTIFY, MESSAGE, INFO, PRACK, UPDATE\n" + 
                            "Content-Length: 0\n\n";

    xlog("[REGISTER_PROCESS] Sending back to $fu \n$var(invite_message)\n");

    send_data("$fu;transport=tcp", "$var(invite_message)");
}

reply_route {
    xlog("[REPLY_ROUTE][$TF] reply for $rm received\n");
}

failure_route {
    xlog("[FAILURE_ROUTE][$TF] failure $rm received\n");
}